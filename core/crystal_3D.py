# Density_Function_Theory - KIT  v1.0.0 
# August 2014
# Class for the crystal (basic 3D types)

import numpy as np
import math
import sys
import copy

from DFT_KIT.core import general_tool
from DFT_KIT.core import atom

class crystal_3D:
    def __init__(self,length_unit=1.0,description='CRYSTAL generated by DFT_KIT'):
        self.description=description
        #define primitive vector (in cartesian coordinate)
        self.primitive_vector=[np.array([1.0,0.0,0.0]),np.array([0.0,1.0,0.0]),np.array([0.0,0.0,1.0])]
        self.inv_primitive_vector=[np.array([0.0,0.0,0.0]),np.array([0.0,0.0,0.0]),np.array([0.0,0.0,0.0])]
        
        #define reciprocal primitive vector (in cartesian coordinate)
        self.reciprocal_vector=[np.array([0.0,0.0,0.0]),np.array([0.0,0.0,0.0]),np.array([0.0,0.0,0.0])]
        self.inv_reciprocal_vector=[np.array([0.0,0.0,0.0]),np.array([0.0,0.0,0.0]),np.array([0.0,0.0,0.0])]
    
        self.length_unit=length_unit
        self.basis_atom_groups={}
        self.basis_element={}
        
        #define common k labels for special points
        self.k_labels={'Gamma': np.array([0.0,0.0,0.0])}
        self.k_directions={}
        self.evaluate_basic()
        self.cart_coordinate=True
    
    def set_coordinate(self,cart):
        self.cart_coordinate=cart
        
    def cart_coordinate(self):
        return self.cart_coordinate
    
    def get_length_unit(self):
        return self.length_unit
    
    def set_length_units(self,leng_):
        self.length_units=leng_
    
    #evaluate the reciprocal vectors and transformation matrix
    def evaluate_basic(self):
        self.evaluate_rec_vectors()
        self.eval_inv_primitive_vec()
        self.eval_inv_reciprocal_vec()
        
    def evaluate_rec_vectors(self):
        self.reciprocal_vector[0]=(2.0*np.pi/np.abs(np.linalg.det(self.primitive_vector)))*np.cross(self.primitive_vector[1],self.primitive_vector[2])
        self.reciprocal_vector[1]=(2.0*np.pi/np.abs(np.linalg.det(self.primitive_vector)))*np.cross(self.primitive_vector[2],self.primitive_vector[0])
        self.reciprocal_vector[2]=(2.0*np.pi/np.abs(np.linalg.det(self.primitive_vector)))*np.cross(self.primitive_vector[0],self.primitive_vector[1])
    
    def eval_inv_primitive_vec(self):
        matrix=self.primitive_vector
        matrixinv=np.linalg.inv(matrix)
        self.inv_primitive_vector[0]=np.array(matrixinv[0,:])
        self.inv_primitive_vector[1]=np.array(matrixinv[1,:])
        self.inv_primitive_vector[2]=np.array(matrixinv[2,:])
        
    def eval_inv_reciprocal_vec(self):
        matrix=self.reciprocal_vector
        matrixinv=np.linalg.inv(matrix)
        self.inv_reciprocal_vector[0]=np.array(matrixinv[0,:])
        self.inv_reciprocal_vector[1]=np.array(matrixinv[1,:])
        self.inv_reciprocal_vector[2]=np.array(matrixinv[2,:])
    
    #tools for primitive vectors and reciprocal vectors
    def prim_to_cart(self,vec_):
        return np.array(vec_[0]*self.primitive_vector[0]+vec_[1]*self.primitive_vector[1]+vec_[2]*self.primitive_vector[2])
    def cart_to_prim(self,vec_):
        return np.array(vec_[0]*self.inv_primitive_vector[0]+vec_[1]*self.inv_primitive_vector[1]+vec_[2]*self.inv_primitive_vector[2])
    def get_prim_vec(self,num_):
        return self.primitive_vector[num_]
    def set_prim_vec(self,num_,vec):
        self.primitive_vector[num_]=np.array(vec)
    def rec_to_cart(self,vec_):
        return np.array(vec_[0]*self.reciprocal_vector[0]+vec_[1]*self.reciprocal_vector[1]+vec_[2]*self.reciprocal_vector[2])
    def cart_to_rec(self,vec_):
        return np.array(vec_[0]*self.inv_reciprocal_vector[0]+vec_[1]*self.inv_reciprocal_vector[1]+vec_[2]*self.inv_reciprocal_vector[2])
    def set_rec_vec(self,vec_num,new_vec):
        self.reciprocal_vector[vec_num]=np.array(new_vec)
    def get_rec_vec(self,vec_num):
        return self.reciprocal_vector[vec_num]
    
    #special k points!!
    def k_distance(self):
        pass
    def special_kpoints(self):
        pass
    def clear_klabels(self):
        self.k_labels={}
        self.k_directions={}
        
    #atoms
    def get_num_atoms(self,group):
        if group in self.basis_atom_groups:
            return len(self.basis_atom_groups[group])
        else:
            return 0
    def get_totnum_atoms(self):
        tot=0
        for group in self.basis_atom_groups:
            tot+=self.get_num_atoms(group)
        return tot
        
    def get_atom(self,group,num):
        return self.basis_atom_groups[group][num]
    def get_atoms_groups(self):
        return self.basis_atom_groups
    def get_atoms_group(self,group):
        return self.basis_atom_groups[group]
    
    def add_atom(self,element,position=np.array([0.0,0.0,0.0]),**parms):
        symbol=element.symbol
        if symbol not in self.basis_atom_groups:
            self.basis_atom_groups[symbol]=[]
            self.basis_element[symbol]=copy.copy(element)
        atom_=atom.atom(element,position,**parms)
        self.basis_atom_groups[symbol].append(atom_)
        return atom_
    def add_atoms(self,element,positions,**parms):
        symbol=element.symbol
        if symbol not in self.basis_atom_groups:
            self.basis_atom_groups[symbol]=[]
            self.basis_element[symbol]=copy.copy(element)
        for position in positions:
            atom_=atom.atom(element,position,**parms)
            self.basis_atom_groups[symbol].append(atom_)
        
    def updata_position(self,pos_list):
        pass
        

# classes for various 3D crystal structure (without any basis atoms)
class cubic_3D(crystal_3D):
    def __init__(self,cubic_length,length_unit=1.0):
        crystal_3D.__init__(self,length_unit)
        self.set_lattice(cubic_length)
        self.define_klabels()
        
    def set_lattice(self,cubic_length):
        self.set_prim_vec(0, [cubic_length,0.0,0.0])
        self.set_prim_vec(1, [0.0,cubic_length,0.0])
        self.set_prim_vec(2, [0.0,0.0,cubic_length])
        if cubic_length !=0.0:
            self.evaluate_basic()
    def define_klabels(self):
        self.k_labels['M']=np.array([0.5,0.5,0.0])
        self.k_labels['X']=np.array([0.5,0.0,0.0])
        #self.k_labels['X2']=np.array([0.0,0.5,0.0])
        #self.k_labels['X3']=np.array([0.0,0.0,0.5])
        self.k_labels['R']=np.array([0.5,0.5,0.5])
        
        #define directions
        self.k_directions['Delta']=['Gamma','X']
        self.k_directions['T']=['M','R']
        self.k_directions['Lambda']=['Gamma','R']
        self.k_directions['Z']=['X','M']
        self.k_directions['Sigma']=['Gamma','M']
        self.k_directions['S']=['X','R'] 
        
class bcc_3D(crystal_3D):
    def __init__(self,bcc_length,length_unit=1.0):
        crystal_3D.__init__(self,length_unit)
        self.set_lattice(bcc_length)
        self.define_klabels()
        
    def set_lattice(self,bcc_length):
        a=bcc_length;
        self.set_prim_vec(0, [-a,a,a])
        self.set_prim_vec(1, [a,-a,a])
        self.set_prim_vec(2, [a,a,-a])
        if bcc_length !=0.0:
            self.evaluate_basic()
    def define_klabels(self):
        self.k_labels['H']=np.array([-0.5,0.5,0.5])
        self.k_labels['N']=np.array([0.0,0.0,0.5])
        self.k_labels['P']=np.array([0.25,0.25,0.25])
        
        self.k_directions['Delta']=['Gamma','H']
        self.k_directions['G']=['H','N']
        self.k_directions['Lambda']=['Gamma','P']
        self.k_directions['D']=['N','P']
        self.k_directions['F']=['H','P']
        self.k_directions['Sigma']=['Gamma','N']

class fcc_3D(crystal_3D):
    def __init__(self,fcc_length,length_unit=1.0):
        crystal_3D.__init__(self,length_unit)
        self.set_lattice(fcc_length)
        self.define_klabels()
        
    def set_lattice(self,fcc_length):
        a=fcc_length;
        self.set_prim_vec(0, [0.0,a,a])
        self.set_prim_vec(1, [a,0.0,a])
        self.set_prim_vec(2, [a,a,0.0])
        if fcc_length !=0.0:
            self.evaluate_basic()
    def define_klabels(self):
        self.k_labels['X']=np.array([0.5,0.0,0.5])
        self.k_labels['L']=np.array([0.5,0.5,0.5])
        self.k_labels['W']=np.array([0.5,0.25,0.75])
        self.k_labels['K']=np.array([3.0/8.0,3.0/8.0,3.0/4.0])
        self.k_labels['U']=np.array([5.0/8.0,0.25,5.0/8.0])
        
        self.k_directions['Delta']=['Gamma','X']
        self.k_directions['Q']=['L','W']
        self.k_directions['Lambda']=['Gamma','L']
        self.k_directions['Z']=['X','W']
        self.k_directions['Sigma']=['Gamma','K']
        self.k_directions['S']=['X','U']
        
class hexagonal_3D(crystal_3D):
    def __init__(self,hex_a_length,hex_c_length,length_unit=1.0):
        crystal_3D.__init__(self,length_unit)
        self.set_lattice(hex_a_length,hex_c_length)
        self.define_klabels()
        
    def set_lattice(self,hex_a_length,hex_c_length):
        a=hex_a_length
        self.set_prim_vec(0, [a,0.0,0.0])
        self.set_prim_vec(1, [a*0.5,a*0.5*np.sqrt(3),0.0])
        self.set_prim_vec(2, [0.0,0.0,hex_c_length])
        if hex_a_length !=0.0:
            self.evaluate_basic()
    def define_klabels(self):
        self.k_labels['A']=np.array([0.0,0.0,0.5])
        self.k_labels['M']=np.array([0.5,0.5,0.0])
        self.k_labels['K']=np.array([2.0/3.0,1.0/3.0,0.0])
        self.k_labels['H']=np.array([2.0/3.0,1.0/3.0,0.5])
        self.k_labels['L']=np.array([0.5,0.5,0.5])
        
        self.k_directions['Delta']=['Gamma','A']
        self.k_directions['T']=['Gamma','K']
        self.k_directions['P']=['K','H']
        self.k_directions['U']=['M','L']
        self.k_directions['Sigma']=['Gamma','M']
        self.k_directions['R']=['A','L']
        self.k_directions['S']=['A','H']
        self.k_directions['Sprime']=['L','H']
        self.k_directions['Tprime']=['M','K']

class tetragonal_3D(crystal_3D):
    def __init__(self,a_=0.0,c_=0.0,length_unit=1.0):
        crystal_3D.__init__(self,length_unit)
        self.set_lattice(a_,c_)
        self.define_klabels()
        
    def set_lattice(self,a_,c_):
        self.set_prim_vec(0, [a_,0.0,0.0])
        self.set_prim_vec(1, [0.0,a_,0.0])
        self.set_prim_vec(2, [0.0,0.0,c_])
        if (a_ !=0.0 and c_!=0.0):
            self.evaluate_basic()
    def define_klabels(self):
        self.k_labels['M']=np.array([0.5,0.5,0.0])
        self.k_labels['X']=np.array([0.5,0.0,0.0])
        #self.k_labels['X2']=np.array([0.0,0.5,0.0])
        #self.k_labels['X3']=np.array([0.0,0.0,0.5])
        self.k_labels['R']=np.array([0.5,0.0,0.5])
        self.k_labels['Z']=np.array([0.0,0.0,0.5])
        self.k_labels['A']=np.array([0.5,0.5,0.5])
        
        #define directions
        self.k_directions['Delta']=['Gamma','X']
        self.k_directions['Y']=['M','X']
        self.k_directions['Lambda']=['Gamma','Z']
        self.k_directions['W']=['X','R']
        self.k_directions['Sigma']=['Gamma','M']
        self.k_directions['V']=['M','A']
        self.k_directions['S']=['Z','A']
        self.k_directions['U']=['Z','R']
        self.k_directions['T']=['R','A']
            
class orthorhombic_3D(crystal_3D):
    def __init__(self,a_=0.0,b_=0.0,c_=0.0,length_unit=1.0):
        crystal_3D.__init__(self,length_unit)
        self.set_lattice(a_,b_,c_)
        self.define_klabels()
        
    def set_lattice(self,a_,b_,c_):
        self.set_prim_vec(0, [a_,0.0,0.0])
        self.set_prim_vec(1, [0.0,b_,0.0])
        self.set_prim_vec(2, [0.0,0.0,c_])
        if (a_ !=0.0 and b_!=0.0 and c_!=0.0):
            self.evaluate_basic()
    def define_klabels(self):
        self.k_labels['S']=np.array([0.5,0.5,0.0])
        self.k_labels['T']=np.array([0.0,0.5,0.5])
        self.k_labels['U']=np.array([0.5,0.0,0.5])
        self.k_labels['X']=np.array([0.5,0.0,0.0])
        self.k_labels['Y']=np.array([0.0,0.5,0.0])
        self.k_labels['Z']=np.array([0.0,0.0,0.5])
        self.k_labels['R']=np.array([0.5,0.5,0.5])
        
        #define directions
        self.k_directions['Delta']=['Gamma','Y']
        self.k_directions['Lambda']=['Gamma','Z']
        self.k_directions['Sigma']=['Gamma','X']
        self.k_directions['A']=['Z','U']
        self.k_directions['B']=['Z','T']
        self.k_directions['C']=['Y','S']
        self.k_directions['D']=['X','S']
        self.k_directions['E']=['T','R']
        self.k_directions['F']=['U','R']
        self.k_directions['G']=['X','U']
        self.k_directions['H']=['Y','T']
        self.k_directions['Q']=['S','R']

class monoclinic_3D(crystal_3D):
    def __init__(self,a_=0.0,b_=0.0,c_=0.0,angle_=0.0,length_unit=1.0):
        crystal_3D.__init__(self,length_unit)
        self.set_lattice(a_,b_,c_,angle_)
        
    def set_lattice(self,a_,b_,c_,angle_):
        self.set_prim_vec(0, [a_,0.0,0.0])
        self.set_prim_vec(1, [b_*np.sin(angle_),b_*np.cos(angle_),0.0])
        self.set_prim_vec(2, [0.0,0.0,c_])
        if (a_ !=0.0 and b_!=0.0 and c_!=0.0):
            self.evaluate_basic()
            
class triclinic_3D(crystal_3D):
    #most general one, need to be modified later
    def __init__(self,a_=0.0,b_=0.0,c_=0.0,angle_=0.0,length_unit=1.0):
        crystal_3D.__init__(self,length_unit)
        self.set_lattice(a_,b_,c_,angle_)
        
    def set_lattice_constant(self,a_,b_,c_,angle_):
        self.set_prim_vec(0, [a_,0.0,0.0])
        self.set_prim_vec(1, [b_*np.sin(angle_),b_*np.cos(angle_),0.0])
        self.set_prim_vec(2, [0.0,0.0,c_])
        if (a_ !=0.0 and b_!=0.0 and c_!=0.0):
            self.evaluate_basic()


class rhombohedral_3D(crystal_3D):
    def __init__(self,rhom_length,angle,length_unit=1.0):
        #angle: radian
        crystal_3D.__init__(self,length_unit)
        self.set_lattice(rhom_length, angle)
        self.define_klabels()
        
        
    def set_lattice(self,rhom_length,angle_):
        trig_length=2.0*np.sin(angle_*0.5)*rhom_length
        h_=np.sqrt(rhom_length**2-(trig_length**2)/3.0)
        #notice the notation change!
        #self.set_prim_vec(0, np.array([trig_length/np.sqrt(3.0),0.0,h_]))
        #self.set_prim_vec(1, np.array([-trig_length/np.sqrt(3.0)/2.0,trig_length*0.5,h_]))
        #self.set_prim_vec(2, np.array([-trig_length/np.sqrt(3.0)/2.0,-trig_length*0.5,h_]))
        self.set_prim_vec(2, np.array([0.0,trig_length/np.sqrt(3.0),h_]))
        self.set_prim_vec(1, np.array([trig_length*0.5,-trig_length/np.sqrt(3.0)/2.0,h_]))
        self.set_prim_vec(0, np.array([-trig_length*0.5,-trig_length/np.sqrt(3.0)/2.0,h_]))
        
        if rhom_length !=0.0:
            self.evaluate_basic()
            
    def define_klabels(self):
        self.k_labels['Z']=np.array([0.5,0.5,0.5])
        self.k_labels['T']=np.array([0.5,0.5,0.5])
        self.k_labels['A']=np.array([0.5,0.0,0.0])
        self.k_labels['L']=np.array([0.5,0.0,0.0])
        self.k_labels['B']=np.array([0.5,0.5,0.0])
        
        #define directions  ???
        self.k_directions['Delta']=['Gamma','X']
        self.k_directions['T']=['M','R']
        self.k_directions['Lambda']=['Gamma','R']
        self.k_directions['Z']=['X','M']
        self.k_directions['Sigma']=['Gamma','M']
        self.k_directions['S']=['X','R']
        




